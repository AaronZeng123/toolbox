<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>策略-脚本匹配工具</title>
  <style>
    :root { --bg:#0f1216; --panel:#151923; --text:#e6ebf5; --muted:#97a1b5; --accent:#4da3ff; --danger:#ff6767; --ok:#50c878; }
    body { margin:0; font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,"PingFang SC","Microsoft Yahei",sans-serif; background: var(--bg); color: var(--text); }
    header { padding:16px 20px; border-bottom:1px solid #222939; }
    header h1 { margin:0; font-size:18px; }
    header p { margin:6px 0 0; color: var(--muted); font-size:13px; }
    .container { padding:18px; display:grid; grid-template-columns: 1fr 1fr; gap:16px; }
    .panel { background: var(--panel); border:1px solid #1d2331; border-radius:10px; padding:14px; }
    .panel h2 { margin:0 0 10px; font-size:16px; }
    textarea { width:100%; min-height:200px; resize:vertical; background:#0c1017; color:var(--text); border:1px solid #222939; border-radius:8px; padding:10px; line-height:1.5; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-top:10px; }
    .btn { background: var(--accent); color:#0b111a; border:none; padding:8px 12px; border-radius:8px; font-weight:600; cursor:pointer; }
    .btn.secondary { background:#232a3a; color:var(--text); }
    .btn:disabled { opacity:0.5; cursor:not-allowed; }
    .options { display:flex; gap:14px; color:var(--muted); font-size:13px; }
    .result { grid-column: 1 / -1; background: var(--panel); border:1px solid #1d2331; border-radius:10px; padding:14px; }
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom:1px solid #222939; padding:8px; vertical-align: top; }
    th { text-align:left; color:var(--muted); font-weight:600; }
    .id { font-variant-numeric: tabular-nums; }
    .missing { color: var(--danger); }
    .badge { display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; background:#232a3a; color:var(--muted); margin-left:8px; }
    .footer-note { color:var(--muted); font-size:12px; margin-top:10px; }
    ul, ol { margin:8px 0; }
    .mono { font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace; }
  </style>
  <script>
    function detectDelimiter(line) {
      if (line.includes('\t')) return '\t';
      if (line.includes(',')) return ',';
      if (line.includes('，')) return '，';
      if (line.includes('|')) return '|';
      // fallback: multiple spaces
      return ' ';
    }

    function splitFields(line, delim) {
      if (delim === '\t') return line.split('\t');
      if (delim === ' ') return line.trim().split(/\s+/);
      return line.split(delim);
    }

    function normalizeIds(expr) {
      if (!expr) return [];
      return expr
        .toString()
        .replace(/\s+/g, ' ')
        .split(/[，,;、\s]+/)
        .map(s => s.trim())
        .filter(s => /^(\d+)$/.test(s));
    }

    function parseStrategies(text) {
      const lines = text.replace(/\r/g, '').split('\n').map(l => l.trim()).filter(Boolean);
      if (!lines.length) return [];
      const delim = detectDelimiter(lines[0]);
      const result = [];
      for (const line of lines) {
        const fields = splitFields(line, delim);
        if (fields.length < 2) continue;
        const first = fields[0].trim();
        const second = fields[1].trim();
        if (!/^\d+$/.test(first)) {
          // header line, skip
          continue;
        }
        result.push({
          strategyId: first,
          rawExpression: second,
          scriptIds: normalizeIds(second)
        });
      }
      return result;
    }

    function parseScripts(text) {
      const lines = text.replace(/\r/g, '').split('\n').map(l => l.trim()).filter(Boolean);
      if (!lines.length) return new Map();
      const delim = detectDelimiter(lines[0]);
      const map = new Map();
      for (const line of lines) {
        const fields = splitFields(line, delim);
        if (!fields.length) continue;
        const first = fields[0].trim();
        // skip header if non-numeric
        if (!/^\d+$/.test(first)) continue;
        const desc = (fields.slice(1).join(delim)).trim();
        if (!desc) continue;
        map.set(first, desc);
      }
      return map;
    }

    function renderResults(strategies, scriptMap, numbered) {
      const container = document.getElementById('result');
      container.innerHTML = '';

      const table = document.createElement('table');
      const thead = document.createElement('thead');
      thead.innerHTML = '<tr><th class="id">策略ID</th><th>规则表达式</th><th>脚本描述</th></tr>';
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      for (const s of strategies) {
        const tr = document.createElement('tr');
        const tdId = document.createElement('td');
        tdId.className = 'id mono';
        tdId.textContent = s.strategyId;
        const tdExpr = document.createElement('td');
        tdExpr.className = 'mono';
        tdExpr.textContent = s.rawExpression;
        const tdDesc = document.createElement('td');

        const list = document.createElement(numbered ? 'ol' : 'ul');
        for (const id of s.scriptIds) {
          const li = document.createElement('li');
          if (scriptMap.has(id)) {
            li.textContent = scriptMap.get(id);
          } else {
            li.innerHTML = `<span class="missing">未找到脚本 ${id}</span>`;
          }
          list.appendChild(li);
        }
        tdDesc.appendChild(list);

        const missingCount = s.scriptIds.filter(id => !scriptMap.has(id)).length;
        if (missingCount > 0) {
          const badge = document.createElement('span');
          badge.className = 'badge';
          badge.textContent = `未匹配：${missingCount}`;
          tdDesc.appendChild(badge);
        }

        tr.appendChild(tdId);
        tr.appendChild(tdExpr);
        tr.appendChild(tdDesc);
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      container.appendChild(table);
    }

    function copyMarkdown() {
      const strategiesText = document.getElementById('strategies').value.trim();
      const scriptsText = document.getElementById('scripts').value.trim();
      const numbered = document.getElementById('style-numbered').checked;
      const strategies = parseStrategies(strategiesText);
      const scriptMap = parseScripts(scriptsText);
      let md = '';
      for (const s of strategies) {
        md += `\n- 策略 \`${s.strategyId}\`:`;
        for (let i = 0; i < s.scriptIds.length; i++) {
          const id = s.scriptIds[i];
          const prefix = numbered ? `${i+1}.` : '-';
          const desc = scriptMap.get(id) || `未找到脚本 ${id}`;
          md += `\n  ${prefix} ${desc}`;
        }
        md += '\n';
      }
      navigator.clipboard.writeText(md).then(() => {
        const tip = document.getElementById('copy-tip');
        tip.textContent = '已复制为 Markdown';
        tip.style.color = 'var(--ok)';
        setTimeout(() => { tip.textContent = ''; }, 2000);
      });
    }

    function runParse() {
      const strategiesText = document.getElementById('strategies').value.trim();
      const scriptsText = document.getElementById('scripts').value.trim();
      const numbered = document.getElementById('style-numbered').checked;
      const strategies = parseStrategies(strategiesText);
      const scriptMap = parseScripts(scriptsText);
      renderResults(strategies, scriptMap, numbered);
      // 缓存最近一次解析结果，供导出使用
      window.__lastResult = { strategies, scriptMap, numbered };
    }

    function ensureParsed() {
      if (!window.__lastResult || !window.__lastResult.strategies?.length) {
        runParse();
      }
      return window.__lastResult;
    }

    function toCSVValue(v) {
      const s = String(v ?? '');
      if (/[",\n]/.test(s)) {
        return '"' + s.replace(/"/g, '""') + '"';
      }
      return s;
    }

    function exportCSV() {
      const data = ensureParsed();
      const { strategies, scriptMap } = data;
      const header = ['策略ID','规则表达式','脚本ID','脚本描述'];
      const rows = [header];
      for (const s of strategies) {
        for (const id of s.scriptIds) {
          const desc = scriptMap.get(id) || `未找到脚本 ${id}`;
          rows.push([s.strategyId, s.rawExpression, id, desc]);
        }
      }
      const bom = '\ufeff'; // 解决中文在 Excel 中显示问题
      const csv = rows.map(r => r.map(toCSVValue).join(',')).join('\n');
      const blob = new Blob([bom + csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'strategy_script_results.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function exportHTMLTable() {
      const data = ensureParsed();
      // 直接获取当前结果表格的 HTML 并打包成独立文件
      const result = document.getElementById('result');
      const tableEl = result.querySelector('table');
      if (!tableEl) { runParse(); }
      const html = `<!doctype html><html><head><meta charset="utf-8"><title>策略-脚本匹配结果</title></head><body>${result.innerHTML}</body></html>`;
      const blob = new Blob([html], { type: 'text/html;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'strategy_script_results.html';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function buildCombinedText(scriptIds, scriptMap, numbered) {
      const lines = [];
      for (let i = 0; i < scriptIds.length; i++) {
        const id = scriptIds[i];
        const desc = scriptMap.get(id) || `未找到脚本 ${id}`;
        const prefix = numbered ? `${i+1}. ` : '• ';
        lines.push(prefix + desc);
      }
      return lines.join('\n');
    }

    function exportCombinedCSV() {
      const data = ensureParsed();
      const { strategies, scriptMap, numbered } = data;
      const header = ['策略ID','规则表达式','脚本描述（合并为一格，按行分隔）'];
      const rows = [header];
      for (const s of strategies) {
        const combined = buildCombinedText(s.scriptIds, scriptMap, numbered);
        rows.push([s.strategyId, s.rawExpression, combined]);
      }
      const bom = '\ufeff';
      const csv = rows.map(r => r.map(toCSVValue).join(',')).join('\n');
      const blob = new Blob([bom + csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'strategy_script_results_combined.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function exportCombinedHTMLTable() {
      const data = ensureParsed();
      const { strategies, scriptMap, numbered } = data;
      const style = `
        <style>
          body { font-family: -apple-system, Segoe UI, Roboto, Helvetica, Arial, 'PingFang SC', 'Microsoft Yahei', sans-serif; color:#1f2328; }
          table { border-collapse: collapse; width: 100%; }
          th, td { border: 1px solid #d0d7de; padding: 8px; vertical-align: top; }
          th { background:#f6f8fa; text-align:left; }
          .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; }
          .pre { white-space: pre-line; }
        </style>
      `;
      const head = '<thead><tr><th class="mono">策略ID</th><th class="mono">规则表达式</th><th>脚本描述（合并）</th></tr></thead>';
      let body = '<tbody>';
      for (const s of strategies) {
        const combined = buildCombinedText(s.scriptIds, scriptMap, numbered);
        body += `<tr><td class="mono">${s.strategyId}</td><td class="mono">${s.rawExpression}</td><td class="pre">${combined}</td></tr>`;
      }
      body += '</tbody>';
      const html = `<!doctype html><html><head><meta charset="utf-8"><title>策略-脚本匹配结果（单表）</title>${style}</head><body><table>${head}${body}</table></body></html>`;
      const blob = new Blob([html], { type: 'text/html;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'strategy_script_results_combined.html';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
  </script>
</head>
<body>
  <header>
    <h1>策略-脚本匹配工具</h1>
    <p>将两张表内容直接粘贴到下方文本框，点击解析后展示每个策略对应的脚本描述。支持 Tab、逗号、中文逗号、竖线分隔。</p>
  </header>

  <div class="container">
    <section class="panel">
      <h2>策略表粘贴区</h2>
      <textarea id="strategies" placeholder="示例（两列：策略ID，规则表达式）：\n65532\t28877\n61428\t52320,51799,51780,52319,52570\n67960\t57155"></textarea>
      <div class="footer-note">需要两列数据：第一列为策略ID（数字），第二列为规则表达式（脚本ID列表）。可包含逗号、中文逗号或空格分隔。</div>
    </section>

    <section class="panel">
      <h2>脚本表粘贴区</h2>
      <textarea id="scripts" placeholder="示例（两列：脚本id，脚本描述）：\n57974\t新开免密或半年首次使用免密产品\n57963\t支付失败后白条预订单\n57956\t夜间0-9点且安装异常app"></textarea>
      <div class="footer-note">需要两列数据：第一列为脚本id（数字），其余列合并为脚本描述。</div>
    </section>

    <section class="panel controls" style="grid-column: 1 / -1;">
      <div class="options">
        <label><input type="radio" name="style" id="style-bulleted" checked> 使用项目符号（•）</label>
        <label><input type="radio" name="style" id="style-numbered"> 使用编号（1. 2. 3.）</label>
      </div>
      <button class="btn" onclick="runParse()">解析匹配</button>
      <button class="btn secondary" onclick="copyMarkdown()">复制结果为 Markdown</button>
      <button class="btn secondary" onclick="exportCSV()">导出为 CSV 表格</button>
      <button class="btn secondary" onclick="exportHTMLTable()">保存当前 HTML 表格</button>
      <button class="btn secondary" onclick="exportCombinedCSV()">导出为单表 CSV（每策略一行）</button>
      <button class="btn secondary" onclick="exportCombinedHTMLTable()">保存单表 HTML（每策略一行）</button>
      <span id="copy-tip" class="footer-note"></span>
    </section>

    <section id="result" class="result">
      <div class="footer-note">解析结果将显示在此处。</div>
    </section>
  </div>

</body>
</html>